// ***********************************************************************
// Assembly         : dotNetTips.Utility.Standard
// Author           : David McCarter
// Created          : 06-26-2017
//
// Last Modified By : David McCarter
// Last Modified On : 06-01-2018
// ***********************************************************************
// <copyright file="ISingleton.cs" company="dotNetTips.com - David McCarter">
//     dotNetTips.com - David McCarter
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;

namespace dotNetTips.Utility.Standard
{
    /// <summary>
    /// A domain-aware singleton. Only one instance of <typeparamref name="T"/> will exist, belonging to the default AppDomain. All members of this type are threadsafe.
    /// </summary>
    /// <typeparam name="T">The type of instance managed by this singleton.</typeparam>
    /// <remarks>Original code by: StephenCleary</remarks>
    public abstract class Singleton<T> where T : class, new()
    {
        /// <summary>
        /// Gets the domain data key for this type. This property may be called from any AppDomain, and will return the same value regardless of AppDomain.
        /// </summary>
        private static string Name
        {
            get { return "BA9A49C7E9364666AC4E4DDDBF465684." + typeof(T).FullName; }
        }

        /// <summary>
        /// A local cache of the instance wrapper.
        /// </summary>
        private static readonly Lazy<Wrapper> LazyInstance = AppDomain.CurrentDomain.IsDefaultAppDomain() ? CreateOnDefaultAppDomain() : CreateOnOtherAppDomain();

        /// <summary>
        /// A local cache of the instance.
        /// </summary>
        private static readonly Lazy<T> CachedLazyInstance = new Lazy<T>(() => Instance);

        /// <summary>
        /// Initializes a new instance of the <see cref="Singleton{T}"/> class.
        /// </summary>
        protected Singleton()
        {
        }

        /// <summary>
        /// Returns a lazy that creates the instance (if necessary) and saves it in the domain data. This method must only be called from the default AppDomain.
        /// </summary>
        private static Lazy<Wrapper> CreateOnDefaultAppDomain()
        {
            return new Lazy<Wrapper>(() =>
            {
                var ret = new Wrapper { WrappedInstance = new T() };
                AppDomain.CurrentDomain.SetData(Name, ret);
                return ret;
            });
        }

        /// <summary>
        /// Returns a lazy that calls into the default domain to create the instance and retrieves a proxy into the current domain.
        /// </summary>
        private static Lazy<Wrapper> CreateOnOtherAppDomain()
        {
            return new Lazy<Wrapper>(() =>
            {
                var defaultAppDomain = AppDomainHelper.DefaultAppDomain;
                var ret = defaultAppDomain.GetData(Name) as Wrapper;
                if (ret != null)
                    return ret;
                // defaultAppDomain.DoCallBack(CreateCallback);
                return (Wrapper)defaultAppDomain.GetData(Name);
            });
        }

        /// <summary>
        /// Ensures the instance is created (and saved in the domain data). This method must only be called on the default AppDomain.
        /// </summary>
        private static void CreateCallback()
        {
            var _ = LazyInstance.Value;
        }

        /// <summary>
        /// Gets the process-wide instance. If the current domain is not the default AppDomain, this property returns a new proxy to the actual instance.
        /// </summary>
        public static T Instance { get { return LazyInstance.Value.WrappedInstance; } }

        /// <summary>
        /// Gets the process-wide instance. If the current domain is not the default AppDomain, this property returns a cached proxy to the actual instance. It is your responsibility to ensure that the cached proxy does not time out; if you don't know what this means, use <see cref="Instance"/> instead.
        /// </summary>
        public static T CachedInstance { get { return CachedLazyInstance.Value; } }

        private sealed class Wrapper : MarshalByRefObject
        {
            public override object InitializeLifetimeService()
            {
                return null;
            }

            public T WrappedInstance { get; set; }
        }
    }

    /// <summary>
    /// Provides utility methods related to the <see cref="AppDomain"/> type. All members of this type are threadsafe.
    /// </summary>
    public static class AppDomainHelper
    {
        /// <summary>
        /// The CorRuntimeHost, as an <see cref="ICorRuntimeHost"/>.
        /// </summary>
        private static readonly Lazy<ICorRuntimeHost> Host = new Lazy<ICorRuntimeHost>(
            () => (ICorRuntimeHost)Activator.CreateInstance(Type.GetTypeFromCLSID(Guid.Parse("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E"))),
            LazyThreadSafetyMode.PublicationOnly);

        /// <summary>
        /// The default AppDomain.
        /// </summary>
        private static readonly Lazy<AppDomain> LazyDefaultAppDomain = new Lazy<AppDomain>(() =>
        {
            object ret;
            Host.Value.GetDefaultDomain(out ret);
            return (AppDomain)ret;
        }, LazyThreadSafetyMode.PublicationOnly);

        /// <summary>
        /// Gets the default AppDomain. This property caches the resulting value.
        /// </summary>
        public static AppDomain DefaultAppDomain
        {
            get { return LazyDefaultAppDomain.Value; }
        }

        /// <summary>
        /// Enumerates all currently-loaded AppDomains.
        /// </summary>
        public static IEnumerable<AppDomain> EnumerateLoadedAppDomains()
        {
            // http://devdale.blogspot.com/2007/10/getting-list-of-loaded-appdomains.html
            var host = Host.Value;
            IntPtr enumeration;
            host.EnumDomains(out enumeration);
            try
            {
                while (true)
                {
                    object domain = null;
                    host.NextDomain(enumeration, ref domain);
                    if (domain == null)
                        yield break;
                    yield return (AppDomain)domain;
                }
            }
            finally
            {
                host.CloseEnum(enumeration);
            }
        }

        [Guid("CB2F6722-AB3A-11D2-9C40-00C04FA30A3E")]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        private interface ICorRuntimeHost
        {
            void _VtblGap_10();
            void GetDefaultDomain([MarshalAs(UnmanagedType.IUnknown)]out object appDomain);
            void EnumDomains(out IntPtr enumHandle);
            void NextDomain(IntPtr enumHandle, [MarshalAs(UnmanagedType.IUnknown)]ref object appDomain);
            void CloseEnum(IntPtr enumHandle);
        }
    }
}